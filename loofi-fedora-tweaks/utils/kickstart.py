"""
Kickstart file generator.
Part of v8.0 "Replicator" update.

Generates Anaconda-compatible Kickstart files for automated
Fedora installations with user's package selection.
"""

import subprocess
import shutil
from dataclasses import dataclass
from typing import Optional
from pathlib import Path
from datetime import datetime

from services.system import SystemManager
from utils.log import get_logger

logger = get_logger(__name__)


@dataclass
class Result:
    """Operation result with message."""

    success: bool
    message: str
    data: Optional[dict] = None


class KickstartGenerator:
    """
    Generates Kickstart files for Fedora installation.

    Scope: Package selection and post-install scripts only.
    Does NOT handle partitioning (users should handle that manually
    or use Anaconda's graphical partitioner).
    """

    KICKSTART_TEMPLATE = """#version=DEVEL
# Kickstart file generated by Loofi Fedora Tweaks v8.0
# Date: {date}
#
# Usage:
#   1. Boot Fedora installation media
#   2. Add to boot: inst.ks=https://your-server.com/loofi.ks
#   Or use local file: inst.ks=hd:sdb1:/loofi.ks
#
# NOTE: This file handles packages and post-install only.
#       Partitioning and other settings use Anaconda defaults.

# Use graphical install
graphical

# Keyboard layout
keyboard --xlayouts='{keyboard}'

# System language
lang {lang}

# System timezone
timezone {timezone} --utc

# Root password (CHANGE THIS or remove for interactive)
# rootpw --lock

# User to create (CHANGE THIS)
# user --name=user --groups=wheel

# Packages to install
%packages
@core
@standard
{packages}
%end

# Flatpak apps (post-install)
%post --interpreter=/bin/bash
# Enable and configure Flathub
flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo

# Install Flatpak apps
{flatpak_commands}

# Custom post-install commands
{post_commands}
%end
"""

    @classmethod
    def _get_keyboard_layout(cls) -> str:
        """Get current keyboard layout."""
        try:
            result = subprocess.run(
                ["localectl", "status"], capture_output=True, text=True, timeout=5
            )
            if result.returncode == 0:
                for line in result.stdout.split("\n"):
                    if "X11 Layout" in line:
                        return line.split(":")[-1].strip() or "us"
            return "us"
        except Exception as e:
            logger.debug("Failed to get keyboard layout: %s", e)
            return "us"

    @classmethod
    def _get_system_lang(cls) -> str:
        """Get current system language."""
        import os

        return os.environ.get("LANG", "en_US.UTF-8")

    @classmethod
    def _get_timezone(cls) -> str:
        """Get current timezone."""
        try:
            result = subprocess.run(
                ["timedatectl", "show", "--property=Timezone", "--value"],
                capture_output=True,
                text=True,
                timeout=5,
            )
            if result.returncode == 0:
                return result.stdout.strip() or "UTC"
            return "UTC"
        except Exception as e:
            logger.debug("Failed to get timezone: %s", e)
            return "UTC"

    @classmethod
    def _get_user_packages(cls) -> list[str]:
        """Get user-installed packages."""
        try:
            if SystemManager.is_atomic():
                import json as _json

                result = subprocess.run(
                    ["rpm-ostree", "status", "--json"],
                    capture_output=True,
                    text=True,
                    timeout=60,
                )
                if result.returncode == 0:
                    data = _json.loads(result.stdout)
                    deployments = data.get("deployments", [])
                    if deployments:
                        packages = deployments[0].get("requested-packages", [])
                        excluded = (
                            "kernel",
                            "glibc",
                            "systemd",
                            "bash",
                            "coreutils",
                            "fedora-",
                        )
                        return [
                            p
                            for p in packages
                            if not any(p.startswith(x) for x in excluded)
                        ]
                return []
            else:
                result = subprocess.run(
                    ["dnf", "repoquery", "--userinstalled", "--qf", "%{name}"],
                    capture_output=True,
                    text=True,
                    timeout=60,
                )
                if result.returncode == 0:
                    packages = [
                        p.strip()
                        for p in result.stdout.strip().split("\n")
                        if p.strip()
                    ]
                    # Filter out kernel and base packages
                    excluded = (
                        "kernel",
                        "glibc",
                        "systemd",
                        "bash",
                        "coreutils",
                        "fedora-",
                    )
                    return [
                        p
                        for p in packages
                        if not any(p.startswith(x) for x in excluded)
                    ]
                return []
        except Exception as e:
            logger.debug("Failed to get user-installed packages: %s", e)
            return []

    @classmethod
    def _get_flatpak_apps(cls) -> list[str]:
        """Get installed Flatpak apps."""
        if not shutil.which("flatpak"):
            return []

        try:
            result = subprocess.run(
                ["flatpak", "list", "--app", "--columns=application"],
                capture_output=True,
                text=True,
                timeout=30,
            )
            if result.returncode == 0:
                return [
                    a.strip() for a in result.stdout.strip().split("\n") if a.strip()
                ]
            return []
        except Exception as e:
            logger.debug("Failed to get Flatpak apps: %s", e)
            return []

    @classmethod
    def generate_kickstart(
        cls,
        include_packages: bool = True,
        include_flatpaks: bool = True,
        custom_post: Optional[str] = None,
        package_limit: int = 200,
    ) -> str:
        """
        Generate a Kickstart file from current system state.

        Args:
            include_packages: Include DNF packages
            include_flatpaks: Include Flatpak apps in %post
            custom_post: Additional post-install commands
            package_limit: Max packages to include (prevent huge files)

        Returns:
            Kickstart file content as string.
        """
        # Gather system info
        keyboard = cls._get_keyboard_layout()
        lang = cls._get_system_lang()
        timezone = cls._get_timezone()

        # Packages
        packages = ""
        if include_packages:
            pkg_list = cls._get_user_packages()[:package_limit]
            packages = "\n".join(pkg_list)

        # Flatpak commands
        flatpak_commands = ""
        if include_flatpaks:
            apps = cls._get_flatpak_apps()
            flatpak_commands = "\n".join(
                f"flatpak install -y flathub {app}" for app in apps
            )

        # Post commands
        post_commands = custom_post or "# Add your custom commands here"

        return cls.KICKSTART_TEMPLATE.format(
            date=datetime.now().isoformat(),
            keyboard=keyboard,
            lang=lang,
            timezone=timezone,
            packages=packages,
            flatpak_commands=flatpak_commands,
            post_commands=post_commands,
        )

    @classmethod
    def save_kickstart(cls, path: Optional[Path] = None, **kwargs) -> Result:
        """
        Generate and save Kickstart file.

        Args:
            path: Output path (default: ~/loofi.ks)
            **kwargs: Arguments passed to generate_kickstart

        Returns:
            Result with path to created file.
        """
        if path is None:
            path = Path.home() / "loofi.ks"
        else:
            path = Path(path)

        try:
            content = cls.generate_kickstart(**kwargs)
            with open(path, "w") as f:
                f.write(content)

            return Result(
                True,
                f"Kickstart saved to: {path}",
                {"path": str(path), "size": len(content)},
            )

        except Exception as e:
            return Result(False, f"Failed to save Kickstart: {e}")

    @classmethod
    def validate_kickstart(cls, path: Path) -> Result:
        """
        Validate a Kickstart file if ksvalidator is available.

        Args:
            path: Path to Kickstart file.

        Returns:
            Result with validation output.
        """
        if not shutil.which("ksvalidator"):
            return Result(True, "ksvalidator not installed - unable to validate")

        try:
            result = subprocess.run(
                ["ksvalidator", str(path)], capture_output=True, text=True, timeout=30
            )

            if result.returncode == 0:
                return Result(True, "Kickstart file is valid")
            else:
                return Result(False, f"Validation errors:\n{result.stderr}")

        except Exception as e:
            return Result(False, f"Validation failed: {e}")
